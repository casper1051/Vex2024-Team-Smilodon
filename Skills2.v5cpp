{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\n\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  int systemTime = Brain.Timer.systemHighResolution();\n  double batteryCurrent = Brain.Battery.current();\n  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);\n\n  // Combine these values into a single integer\n  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;\n\n  // Set the seed\n  srand(seed);\n}\n\n\n\nvoid vexcodeInit() {\n\n  //Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       Team Smiliodon                                            */\n/*    Created:      02/04/2025                                                */\n/*    Description:  Basic Driving w/ quadr. power curve and basic skill auto  */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n#include \"vex.h\"\n#include<cmath>\n\nusing namespace vex;\n\n// Driving motors\nvex::motor left_motor = motor(PORT1, false);\nvex::motor right_motor = motor(PORT10, true);\nvex::motor left_motor2 = motor(PORT3, false);\nvex::motor right_motor2 = motor(PORT2, true);\nvex::motor ramp_motor = motor(PORT8, false);\nvex::motor second_ramp_motor = motor(PORT9, true);\nvex::motor arm = motor(PORT18, ratio36_1, false);\nvex::motor lifter = motor(PORT19, ratio36_1, false);\ninertial Inertia(PORT4);\n\nmotor_group leftMotors = motor_group(left_motor, left_motor2);\nmotor_group rightMotors = motor_group(right_motor, right_motor2);\n\ndrivetrain Drivetrain(leftMotors, rightMotors, 259.34, 320, 40, mm, 1.8);\n\n// Clamp motor or servo (assuming it's a motor for simplicity)\nvex::digital_out clamp = digital_out(Brain.ThreeWirePort.A);\nvex::digital_out grabber = digital_out(Brain.ThreeWirePort.B);\n\nbool ramp_enabled = false;\nbool is_ramp_spinning = false;\nbool ready = false;\n\n// Main controller\nvex::controller Controller = controller(primary);\n\nvoid onevent_Controller1ButtonL1_pressed_0() {\n  clamp.set(false);\n}\n\nvoid onevent_Controller1ButtonL2_pressed_0() {\n  clamp.set(true);\n}\n\nvoid clamp_down() {\n  clamp.set(false);\n}\n\nvoid clamp_up() {\n  clamp.set(true);\n}\n\nvoid wall_reset() {\n  arm.setVelocity(15, percent);\n  lifter.setVelocity(20, percent);\n  grabber.set(false);\n\n  if (ready == true) {\n    arm.spinToPosition(-85, degrees);\n    lifter.spinToPosition(0, degrees, false);\n    task::sleep(400);\n    arm.spinToPosition(0, degrees, false);\n  }\n\n  ready = false;\n}\n\nvoid wall_ready() {\n  arm.setVelocity(80, percent);\n  lifter.setVelocity(80, percent);\n\n  if (ready == false) {\n    task::sleep(100);\n    arm.spinToPosition(20, degrees);\n    lifter.spinToPosition(-190, degrees, false);\n    task::sleep(50);\n    arm.spinToPosition(-85, degrees);\n    ready = true;\n  }\n}\n\nvoid wall_score() {\n  grabber.set(false);\n}\n\nvoid rotate_right(int deg) {\n  if (deg <= 0) {\n    return;\n  }\n  Drivetrain.turn(left);\n  Drivetrain.setTurnVelocity(20, percent);\n  while (Inertia.heading(degrees) < deg-3) {\n    \n  }\n  Drivetrain.stop();\n  return;\n}\n\nvoid rotate_left(int deg) {\n    if (deg <= 0) {\n      return;\n    }\n    Drivetrain.turn(right);\n    Drivetrain.setTurnVelocity(20, percent);\n    while (Inertia.heading(degrees) > deg+3) {\n    \n    }\n    Drivetrain.stop();\n    return;\n}\n\nvoid autonomous_skills(){\n  Inertia.setHeading(2, degrees);\n  arm.setVelocity(50, percent);\n  lifter.setVelocity(50, percent);\n\n  arm.setStopping(hold);\n  lifter.setStopping(hold);\n\n  //motor_group leftMotors = motor_group(left_motor, left_motor2);\n  //2motor_group rightMotors = motor_group(right_motor, right_motor2);\n  motor_group rampMotors = motor_group(ramp_motor, second_ramp_motor);\n  //drivetrain Drivetrain = drivetrain(leftMotors, rightMotors, 259.34, 320, 40, mm, 1.8);\n  Drivetrain.setDriveVelocity(40, percent);\n\n  Drivetrain.driveFor(2, inches); // Go to stake\n  rampMotors.spin(forward, 100, percent); // Position ring\n  task::sleep(1000);\n  rampMotors.spin(forward, 0, percent); // Stop ring\n  task::sleep(200);\n  Drivetrain.driveFor(-1.5, inches); // Go back a bit\n  task::sleep(200);\n  rampMotors.spin(forward, 100, percent); // Put ring on stake\n  task::sleep(2000);\n\n  Drivetrain.driveFor(-9, inches); // Back away from the stake\n  clamp_up(); // Get the clamp ready\n  rotate_right(90);\n      arm.spinToPosition(20, degrees);\n      lifter.spinToPosition(-180, degrees, false);\n      task::sleep(150);\n      arm.spinToPosition(-85, degrees);\n  Drivetrain.driveFor(30, inches); // Get to the mogo\n  clamp_down(); // Clamp the mogo\n  rotate_right(270);\n  Drivetrain.driveFor(-33, inches); // Get the two rings\n  task::sleep(800);\n  Drivetrain.driveFor(8, inches); // Back away\n  rampMotors.spin(forward, 0, percent); // Stop rings\n  rotate_left(45);\n  Drivetrain.driveFor(15, inches); // Put mogo in corner\n  rampMotors.spin(forward, 100, percent); // Continue ramp\n  task::sleep(1000);\n  clamp_up(); // Unclamp mogo\n  task::sleep(200);\n  Drivetrain.driveFor(-11, inches); // Exit corner\n\n  Drivetrain.turnFor(100, degrees); // Turn to face next mogo\n  rotate_left(275);\n  Drivetrain.driveFor(79, inches); // Get to next mogo\n  clamp_down(); // Clamp the mogo\n  rotate_left(95);\n  Drivetrain.driveFor(-38, inches); // Get the two rings\n  task::sleep(500);\n  Drivetrain.driveFor(12, inches); // Back away\n  rotate_right(318);\n  Drivetrain.driveFor(20, inches); // Put mogo in corner\n  task::sleep(3000);\n  clamp_up(); // Unclamp mogo\n  task::sleep(200);\n  Drivetrain.driveFor(-20, inches); // Exit corner\n\n  // to go forward/backward use: Drivetrain.driveFor(num, inches);\n  // to turn use: Drivetrain.turnFor(num, degrees);\n\n}\nvoid driver_skills(){\n  while (true) {\n    arm.setVelocity(20, percent);\n    lifter.setVelocity(20, percent);\n\n    arm.setStopping(hold);\n    lifter.setStopping(hold);\n\n    // Creates variables for computational handling\n    int leftcalc;\n    int rightcalc;\n\n    // Because of squaring a number, if statements are used for positive and negative\n    if (-Controller.Axis3.position() >= 0) {\n        leftcalc = pow(-Controller.Axis3.position()/10, 2.0);\n    } else {\n        leftcalc = -pow(-Controller.Axis3.position()/10, 2.0);\n    }\n\n    if (-Controller.Axis2.position() >= 0) {\n        rightcalc = pow(-Controller.Axis2.position()/10, 2.0);\n    } else {\n        rightcalc = -pow(-Controller.Axis2.position()/10, 2.0);\n    }\n    \n    // Sets left and right for easier readability\n    int left = leftcalc;\n    int right = rightcalc;\n\n    // Check for ramp control button press for continuous spinning\n    if (Controller.ButtonA.pressing() && !is_ramp_spinning) {\n        ramp_enabled = !ramp_enabled;\n        is_ramp_spinning = true; // Prevent rapid toggling on hold\n    } else if (!Controller.ButtonA.pressing()) {\n        is_ramp_spinning = false; // Reset the flag when the button is released\n    }\n\n    // Set the velocity of the motors based on joystick input\n    left_motor.setVelocity(left, percent);\n    right_motor.setVelocity(right, percent);\n    right_motor2.setVelocity(right, percent);\n    left_motor2.setVelocity(left, percent);\n\n    // Control the ramp motor\n    if(Controller.ButtonR1.pressing() || Controller.ButtonR2.pressing()){\n        ramp_enabled = false;\n    }\n\n    if (ramp_enabled || Controller.ButtonR1.pressing()) {\n        ramp_motor.setVelocity(100, percent);\n        ramp_motor.spin(forward);\n        second_ramp_motor.setVelocity(100, percent);\n        second_ramp_motor.spin(forward);\n    } else if (Controller.ButtonR2.pressing()) {\n        ramp_motor.setVelocity(100, percent);\n        ramp_motor.spin(reverse);\n        second_ramp_motor.setVelocity(100, percent);\n        second_ramp_motor.spin(reverse);\n    } else {\n        ramp_motor.stop();\n        second_ramp_motor.stop();\n    }\n    if (Controller.ButtonDown.pressing()) {\n      wall_reset();\n    }\n\n    if (Controller.ButtonB.pressing()) {\n      wall_ready();\n    }\n\n    if (Controller.ButtonUp.pressing()) {\n      wall_score();\n    }\n\n    // Spin the motors based on the set velocity\n    left_motor.spin(forward);\n    right_motor.spin(forward);\n    left_motor2.spin(forward);\n    right_motor2.spin(forward);\n\n    // Allow other tasks to run\n    this_thread::sleep_for(20);\n    }\n}\n\nint main() {\n    // Set the default speed to 0 to prevent the motors from spinning indefinitely\n    left_motor.setVelocity(0, percent);\n    right_motor.setVelocity(0, percent);\n    left_motor2.setVelocity(0, percent);\n    right_motor2.setVelocity(0, percent);\n    ramp_motor.setVelocity(0, percent);\n    second_ramp_motor.setVelocity(0, percent);\n\n    // Register event handlers for clamp control\n    Controller.ButtonL1.pressed(onevent_Controller1ButtonL1_pressed_0);\n    Controller.ButtonL2.pressed(onevent_Controller1ButtonL2_pressed_0);\n    competition Competition = competition();\n    Competition.autonomous(autonomous_skills);\n    Competition.drivercontrol(driver_skills);\n\n    \n        \n \n}","textLanguage":"cpp","robotConfig":[],"slot":1,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}